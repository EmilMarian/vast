# data-server/vulnerability_manager.py
import logging
import random
from typing import Optional, Dict, Any, List
from models.models import SensorReading

logger = logging.getLogger("data-server.vulnerability_manager")

class VulnerabilityManager:
    """
    Manages deliberately introduced vulnerabilities in the Data Server.
    This is component is intended for cybersecurity education and testing.
    """
    
    def __init__(self):
        """Initialize the vulnerability manager with default settings"""
        # Available vulnerabilities
        self.data_vulnerabilities = [
            "none",             # No vulnerability
            "offset",           # Add constant offset to all readings
            "random_noise",     # Add random noise to readings
            "inversion",        # Invert readings against a baseline
            "freeze",           # Freeze readings at a particular value
            "missing_data",     # Occasionally return None instead of readings
            "extreme_values"    # Return unrealistic extreme values
        ]
        
        self.request_vulnerabilities = [
            "none",             # No vulnerability
            "delay",            # Add artificial delay to responses
            "data_leak",        # Leak sensitive data in responses
            "error_500",        # Occasionally return 500 Internal Server Error
            "corruption"        # Return partially corrupted data
        ]
        
        # Current active vulnerabilities
        self.active_data_vulnerability = "none"
        self.active_request_vulnerability = "none"
        self.auth_bypass_enabled = False
        self.vulnerability_probability = 0.3  # 30% chance to apply vulnerability when enabled
        
        logger.info("Vulnerability manager initialized")
    
    def set_data_vulnerability(self, vulnerability: str) -> None:
        """
        Set the active data vulnerability
        
        Args:
            vulnerability: The vulnerability to set
        """
        if vulnerability in self.data_vulnerabilities:
            self.active_data_vulnerability = vulnerability
            logger.info(f"Set active data vulnerability to: {vulnerability}")
        else:
            logger.warning(f"Invalid data vulnerability: {vulnerability}")
    
    def set_request_vulnerability(self, vulnerability: str) -> None:
        """
        Set the active request vulnerability
        
        Args:
            vulnerability: The vulnerability to set
        """
        if vulnerability in self.request_vulnerabilities:
            self.active_request_vulnerability = vulnerability
            logger.info(f"Set active request vulnerability to: {vulnerability}")
        else:
            logger.warning(f"Invalid request vulnerability: {vulnerability}")
    
    def set_auth_bypass(self, enabled: bool) -> None:
        """
        Enable or disable authentication bypass
        
        Args:
            enabled: Whether to enable authentication bypass
        """
        self.auth_bypass_enabled = enabled
        logger.info(f"Set authentication bypass to: {enabled}")
    
    def should_inject_data_vulnerability(self) -> bool:
        """
        Determine if a data vulnerability should be injected
        
        Returns:
            True if a data vulnerability should be injected, False otherwise
        """
        if self.active_data_vulnerability == "none":
            return False
        
        # Apply vulnerability with specified probability
        return random.random() < self.vulnerability_probability
    
    def should_inject_request_vulnerability(self) -> bool:
        """
        Determine if a request vulnerability should be injected
        
        Returns:
            True if a request vulnerability should be injected, False otherwise
        """
        if self.active_request_vulnerability == "none":
            return False
        
        # Apply vulnerability with specified probability
        return random.random() < self.vulnerability_probability
    
    def should_bypass_auth(self) -> bool:
        """
        Determine if authentication should be bypassed
        
        Returns:
            True if authentication should be bypassed, False otherwise
        """
        if not self.auth_bypass_enabled:
            return False
        
        # Bypass authentication with specified probability  
        return random.random() < self.vulnerability_probability
    
    def get_active_data_vulnerability(self) -> str:
        """
        Get the currently active data vulnerability
        
        Returns:
            The active data vulnerability
        """
        return self.active_data_vulnerability
    
    def get_active_request_vulnerability(self) -> str:
        """
        Get the currently active request vulnerability
        
        Returns:
            The active request vulnerability
        """
        return self.active_request_vulnerability
    
    def apply_data_vulnerability(self, reading: SensorReading, vulnerability_type: str) -> SensorReading:
        """
        Apply a specific vulnerability to a sensor reading
        
        Args:
            reading: The original sensor reading
            vulnerability_type: The type of vulnerability to apply
            
        Returns:
            The modified sensor reading
        """
        logger.debug(f"Applying '{vulnerability_type}' vulnerability to reading: {reading.value}")
        
        if vulnerability_type == "none":
            return reading
        
        # Make a copy of the reading to modify
        modified_reading = SensorReading(
            value=reading.value,
            unit=reading.unit,
            timestamp=reading.timestamp
        )
        
        # Apply the vulnerability
        if vulnerability_type == "offset":
            # Add a constant offset
            offset = random.uniform(10.0, 20.0)
            modified_reading.value += offset
            logger.debug(f"Applied offset of {offset}")
            
        elif vulnerability_type == "random_noise":
            # Add random noise
            noise = random.uniform(-5.0, 5.0)
            modified_reading.value += noise
            logger.debug(f"Applied random noise of {noise}")
            
        elif vulnerability_type == "inversion":
            # Invert around the baseline of 25Â°C
            baseline = 25.0
            modified_reading.value = baseline - (modified_reading.value - baseline)
            logger.debug(f"Applied inversion around baseline {baseline}")
            
        elif vulnerability_type == "freeze":
            # Freeze at a specific value
            modified_reading.value = 22.5  # Fixed value
            logger.debug("Applied freeze to fixed value")
            
        elif vulnerability_type == "missing_data":
            # 50% chance to return None instead of a value
            if random.random() < 0.5:
                return None
                
        elif vulnerability_type == "extreme_values":
            # Return an extreme value
            if random.random() < 0.5:
                modified_reading.value = random.uniform(50.0, 100.0)  # Very hot
            else:
                modified_reading.value = random.uniform(-50.0, -10.0)  # Very cold
            logger.debug(f"Applied extreme value: {modified_reading.value}")
        
        # Round to 2 decimal places for realism
        if modified_reading.value is not None:
            modified_reading.value = round(modified_reading.value, 2)
        
        logger.debug(f"Final modified reading: {modified_reading.value}")
        return modified_reading